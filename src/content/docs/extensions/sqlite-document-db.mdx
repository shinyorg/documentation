---
title: SQLite Document DB
---
import NugetBadge from '/src/components/NugetBadge.tsx';
import { Steps } from '@astrojs/starlight/components';

A lightweight SQLite-based document store for .NET that turns SQLite into a schema-free JSON document database with LINQ querying and full AOT/trimming support. Store entire object graphs — nested objects, child collections — as JSON documents. No `CREATE TABLE`, no `ALTER TABLE`, no JOINs, no migrations.

- [GitHub Repository](https://github.com/shinyorg/SqliteDocumentDb)
- <NugetBadge name="Shiny.SqliteDocumentDb" showLabel={true} />

## Features

- **Zero schema, zero migrations** — store objects as JSON documents
- **LINQ expression queries** — `o => o.ShippingAddress.City == "Portland"` translates to `json_extract` SQL automatically
- **`IAsyncEnumerable<T>` streaming** — yield results one-at-a-time with `GetAllStream` and `QueryStream`
- **Expression-based JSON indexes** — up to **30x faster** queries on indexed properties
- **SQL-level projections** — project into DTOs with `json_object` at the database level
- **Full AOT/trimming support** — every API has a `JsonTypeInfo<T>` overload for source-generated JSON
- **10-30x faster nested inserts** vs sqlite-net — one write per document vs multiple table inserts
- **Transactions** — `RunInTransaction` with automatic commit/rollback

## Replacing EF Core on .NET MAUI

Entity Framework Core is a natural choice for server-side .NET, but it becomes a liability on .NET MAUI platforms (iOS, Android, Mac Catalyst).

### Why EF Core is a poor fit for MAUI

- **No AOT support.** EF Core relies on runtime reflection and dynamic code generation for change tracking, query compilation, and model building. Its public API carries `[RequiresDynamicCode]` and `[RequiresUnreferencedCode]` attributes. On iOS, where Apple prohibits JIT compilation entirely, this is a non-starter for fully native AOT deployments.
- **Migrations add complexity without value.** On a mobile device, the database is created on first launch or ships inside the app bundle. EF Core's migration pipeline (`Add-Migration`, `Update-Database`, `__EFMigrationsHistory`) solves a problem that doesn't exist here.
- **Heavy dependency graph.** EF Core pulls in `Microsoft.EntityFrameworkCore`, its SQLite provider, design-time packages, and their transitive dependencies — increasing app bundle size on platforms where download size matters.
- **Relational overhead for document-shaped data.** Mobile apps typically store user preferences, cached API responses, offline data queues, and local state. This data is naturally nested and variable. Normalizing it into tables with foreign keys and JOINs adds accidental complexity.

| Concern | EF Core | Shiny.SqliteDocumentDb |
|---|---|---|
| **AOT / trimming** | Reflection-heavy; no AOT support | Every API has a `JsonTypeInfo<T>` overload; zero reflection |
| **Migrations** | Required for every schema change | Not needed — schema-free JSON |
| **Nested objects** | Normalized tables, foreign keys, JOINs | Single document, single write, single read |
| **App bundle size** | Large dependency tree | Single dependency on `Microsoft.Data.Sqlite` |
| **Startup time** | DbContext model building, migration checks | Open connection and go |

### Why AOT and trimming matter on mobile

Ahead-of-Time compilation is not optional on Apple platforms — iOS, iPadOS, tvOS, and Mac Catalyst all prohibit JIT at the OS level. Android benefits from AOT (`PublishAot` or `AndroidEnableProfiledAot`) with faster startup and lower memory usage.

The .NET trimmer removes unreferenced code to shrink the app binary. Libraries that depend on reflection break under trimming because the trimmer cannot statically determine which types are accessed at runtime. This forces developers to either disable trimming (larger binaries) or maintain complex trimmer XML files.

This library avoids both problems:

- **Source-generated JSON serialization.** The `JsonSerializerContext` pattern generates serialization code at compile time. The trimmer and AOT compiler can see every type and code path.
- **No runtime expression compilation.** LINQ expressions are translated to SQL strings by a visitor — no `Expression.Compile()`, no `Reflection.Emit`, no dynamic delegates.
- **No model building.** There is no equivalent of EF Core's `OnModelCreating` that discovers entities through reflection at startup.

## Setup

<Steps>
1. Install the NuGet package

   <NugetBadge name="Shiny.SqliteDocumentDb" showLabel={true} />

   ```bash
   dotnet add package Shiny.SqliteDocumentDb
   ```

2. Register with dependency injection:
   ```csharp
   services.AddSqliteDocumentStore("Data Source=mydata.db");

   // or with full options
   services.AddSqliteDocumentStore(opts =>
   {
       opts.ConnectionString = "Data Source=mydata.db";
       opts.TypeNameResolution = TypeNameResolution.FullName;
       opts.JsonSerializerOptions = new JsonSerializerOptions
       {
           PropertyNamingPolicy = JsonNamingPolicy.CamelCase
       };
   });
   ```

   Or instantiate directly:
   ```csharp
   var store = new SqliteDocumentStore(new DocumentStoreOptions
   {
       ConnectionString = "Data Source=mydata.db"
   });
   ```

3. Inject `IDocumentStore` and start using it:
   ```csharp
   public class MyService(IDocumentStore store)
   {
       public async Task SaveUser(User user)
       {
           await store.Set("user-1", user, ctx.User);
       }

       public async Task<User?> GetUser(string id)
       {
           return await store.Get<User>(id, ctx.User);
       }
   }
   ```
</Steps>

### Configuration Options

| Property | Type | Default | Description |
|----------|------|---------|-------------|
| `ConnectionString` | `string` (required) | — | SQLite connection string |
| `TypeNameResolution` | `TypeNameResolution` | `ShortName` | How type names are stored (`ShortName` or `FullName`) |
| `JsonSerializerOptions` | `JsonSerializerOptions?` | camelCase, no indent | JSON serialization settings |

## AOT Setup

For AOT/trimming compatibility, create a source-generated JSON context:

```csharp
[JsonSerializable(typeof(User))]
[JsonSerializable(typeof(Order))]
[JsonSerializable(typeof(Address))]
[JsonSerializable(typeof(OrderLine))]
public partial class AppJsonContext : JsonSerializerContext;
```

Create an instance with your desired options:

```csharp
var ctx = new AppJsonContext(new JsonSerializerOptions
{
    PropertyNamingPolicy = JsonNamingPolicy.CamelCase
});
```

:::caution
Pass `ctx.Options` to `DocumentStoreOptions.JsonSerializerOptions` so the expression visitor and serializer share the same naming configuration. Without this, property names in LINQ expressions won't match the stored JSON.
:::

## Basic CRUD Operations

### Store a document

```csharp
// Auto-generated GUID key — returns the ID
var id = await store.Set(new User { Name = "Alice", Age = 25 }, ctx.User);

// Explicit key
await store.Set("user-1", new User { Name = "Alice", Age = 25 }, ctx.User);
```

### Get a document

```csharp
var user = await store.Get<User>("user-1", ctx.User);
```

### Get all documents of a type

```csharp
var users = await store.GetAll<User>(ctx.User);
```

### Remove a document

```csharp
// By ID
bool deleted = await store.Remove<User>("user-1");

// By expression — returns number deleted
int deleted = await store.Remove<User>(u => u.Age < 18, ctx.User);
```

### Clear all documents of a type

```csharp
int deletedCount = await store.Clear<User>();
```

## Querying

### Expression-based queries (AOT-safe)

Property names are resolved from `JsonTypeInfo` metadata, so `[JsonPropertyName]` attributes and naming policies are respected automatically.

```csharp
// Equality and comparisons
var results = await store.Query<User>(u => u.Name == "Alice", ctx.User);
var older = await store.Query<User>(u => u.Age > 30, ctx.User);

// Logical operators
var results = await store.Query<User>(u => u.Age == 25 && u.Name == "Alice", ctx.User);
var results = await store.Query<User>(u => u.Name == "Alice" || u.Name == "Bob", ctx.User);

// Null checks
var noEmail = await store.Query<User>(u => u.Email == null, ctx.User);

// String methods
var results = await store.Query<User>(u => u.Name.Contains("li"), ctx.User);
var results = await store.Query<User>(u => u.Name.StartsWith("Al"), ctx.User);

// Nested properties
var results = await store.Query<Order>(o => o.ShippingAddress.City == "Portland", ctx.Order);

// Collection queries with Any()
var results = await store.Query<Order>(
    o => o.Lines.Any(l => l.ProductName == "Widget"), ctx.Order);
var results = await store.Query<Order>(
    o => o.Tags.Any(t => t == "priority"), ctx.Order);

// Collection queries with Count()
var results = await store.Query<Order>(o => o.Lines.Count() > 1, ctx.Order);

// DateTime comparisons (ISO 8601 formatted)
var cutoff = new DateTime(2025, 1, 1, 0, 0, 0, DateTimeKind.Utc);
var upcoming = await store.Query<Event>(e => e.StartDate > cutoff, ctx.Event);

// Captured variables
var targetName = "Alice";
var results = await store.Query<User>(u => u.Name == targetName, ctx.User);
```

### Counting

```csharp
var count = await store.Count<User>(u => u.Age == 25, ctx.User);

// Raw SQL
var count = await store.Count<User>(
    "json_extract(Data, '$.age') > @minAge",
    new { minAge = 30 });
```

### Raw SQL queries

```csharp
var results = await store.Query<User>(
    "json_extract(Data, '$.name') = @name",
    ctx.User,
    new { name = "Alice" });

// With dictionary parameters (fully AOT-safe)
var parms = new Dictionary<string, object?> { ["name"] = "Alice" };
var results = await store.Query<User>(
    "json_extract(Data, '$.name') = @name",
    ctx.User,
    parms);
```

## Projections

Project query results into a different shape at the SQL level via `json_object` — no full document deserialization needed.

```csharp
// Flat projection
var results = await store.Query<User, UserSummary>(
    u => u.Age == 25,
    u => new UserSummary { Name = u.Name, Email = u.Email },
    ctx.User,
    ctx.UserSummary);

// Nested source properties
var results = await store.Query<Order, OrderSummary>(
    o => o.Status == "Shipped",
    o => new OrderSummary { Customer = o.CustomerName, City = o.ShippingAddress.City },
    ctx.Order,
    ctx.OrderSummary);

// GetAll with projection
var results = await store.GetAll<Order, OrderDetail>(
    o => new OrderDetail { Customer = o.CustomerName, LineCount = o.Lines.Count() },
    ctx.Order,
    ctx.OrderDetail);

// Collection methods in projections: Count(), Any(), Count(predicate), Any(predicate)
o => new OrderDetail { HasLines = o.Lines.Any(), GadgetCount = o.Lines.Count(l => l.ProductName == "Gadget") }
```

## Streaming

All list-returning methods have `IAsyncEnumerable<T>` streaming counterparts that yield results one-at-a-time without buffering.

```csharp
// Stream all documents
await foreach (var user in store.GetAllStream<User>(ctx.User))
{
    Console.WriteLine(user.Name);
}

// Stream with expression filter
await foreach (var user in store.QueryStream<User>(u => u.Age > 30, ctx.User))
{
    Console.WriteLine(user.Name);
}

// Stream with projection
await foreach (var summary in store.GetAllStream<Order, OrderSummary>(
    o => new OrderSummary { Customer = o.CustomerName, City = o.ShippingAddress.City },
    ctx.Order,
    ctx.OrderSummary))
{
    Console.WriteLine($"{summary.Customer} in {summary.City}");
}
```

:::note
Streaming methods hold the internal semaphore for the duration of enumeration. Consume results promptly and avoid interleaving other store operations within the same `await foreach` loop.
:::

## Index Management

For frequently queried JSON properties, create expression indexes on `json_extract` to speed up lookups. These methods are on `SqliteDocumentStore` directly (not on `IDocumentStore`).

```csharp
// Create an index — up to 30x faster queries
await store.CreateIndexAsync<User>(u => u.Name, ctx.User);

// Nested properties
await store.CreateIndexAsync<Order>(o => o.ShippingAddress.City, ctx.Order);

// Drop a specific index
await store.DropIndexAsync<User>(u => u.Name, ctx.User);

// Drop all indexes for a type
await store.DropAllIndexesAsync<User>();
```

`CreateIndexAsync` uses `IF NOT EXISTS`, so calling it multiple times is safe. Index names are deterministic (`idx_json_{typeName}_{jsonPath}`).

## Transactions

```csharp
await store.RunInTransaction(async tx =>
{
    await tx.Set("u1", new User { Name = "Alice", Age = 25 }, ctx.User);
    await tx.Set("u2", new User { Name = "Bob", Age = 30 }, ctx.User);
    // Commits on success, rolls back on exception
});
```

## Supported Expression Reference

| Expression | SQL Output |
|---|---|
| `u.Name == "Alice"` | `json_extract(Data, '$.name') = @p0` |
| `u.Age > 25` | `json_extract(Data, '$.age') > @p0` |
| `u.Age == 25 && u.Name == "Alice"` | `(... AND ...)` |
| `u.Name == "A" \|\| u.Name == "B"` | `(... OR ...)` |
| `!(u.Name == "Alice")` | `NOT (...)` |
| `u.Email == null` | `... IS NULL` |
| `u.Email != null` | `... IS NOT NULL` |
| `u.Name.Contains("li")` | `... LIKE '%' \|\| @p0 \|\| '%'` |
| `u.Name.StartsWith("Al")` | `... LIKE @p0 \|\| '%'` |
| `u.Name.EndsWith("ob")` | `... LIKE '%' \|\| @p0` |
| `o.ShippingAddress.City == "X"` | `json_extract(Data, '$.shippingAddress.city') = @p0` |
| `o.Lines.Any(l => l.Name == "X")` | `EXISTS (SELECT 1 FROM json_each(...) WHERE ...)` |
| `o.Tags.Any(t => t == "priority")` | `EXISTS (SELECT 1 FROM json_each(...) WHERE value = @p0)` |
| `o.Tags.Any()` | `json_array_length(Data, '$.tags') > 0` |
| `o.Lines.Count() > 1` | `json_array_length(Data, '$.lines') > 1` |
| `o.Lines.Count(l => l.Qty > 2)` | `(SELECT COUNT(*) FROM json_each(...) WHERE ...)` |
| `e.StartDate > cutoff` | `json_extract(Data, '$.startDate') > @p0` (ISO 8601) |
