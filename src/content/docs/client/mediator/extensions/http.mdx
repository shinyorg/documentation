---
title: HTTP
---
import { Steps } from '@astrojs/starlight/components';

HTTP requests are basically a must in every app.  We didn't want people to have to generate their API client, contracts, and then have to global
add the boilerplate mediator contract and subsequent request handler, so... we found some very convenient ways to build this in.

<Steps>
1. Let's start with our mediator request contract - Notice that we have some attributes & interfaces that are specific to HTTP requests

   ```csharp
   using Shiny.Mediator;
   using Shiny.Mediator.Http;

   [Http("/route/{Parameter}")]
   public class MyRequest : IHttpRequest<MyResponse>
   {
       [HttpParameter]
       public string Parameter { get; set; }

       [HttpBody]
       public SomeOtherClass Body { get; set; }
   }
   ```

2. Next, let's create our configuration for the base URI

    ```json
    {
        "Mediator": {
            "Http": {
                "Your.Namespace": "https://yourapi.com"
            }
        }
    }
    ```

3. Now - let's make the request with mediator
</Steps>

## Adding Cache/Offline Support

```csharp
[OfflineAvailable]
[Cache]
public partial class MyRequest
{

}
```

## Generating All The Contracts and Responses

```xml
<ItemGroup>
    <MediatorHttp Include="OpenApiDoc.json" Namespace="My.Namespace" ContractPrefix="optional" ContractPostfix="HttpRequest" />
    <MediatorHttp Include="OpenApiRemote" Uri="https://someurl.com" Namespace="My.RemoteNamespace" ContractPrefix="optional" ContractPostfix="HttpRequest" />
</ItemGroup>
```

## Adding Cache/Offline Support to Generated

```csharp
[OfflineAvailable]
[Cache]
public partial class MyRequest
{

}
```