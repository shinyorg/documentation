---
title: Middleware
---
import { Image } from 'astro:assets';
import diagramImg from  '/src/assets/middleware.png';


<Image src={diagramImg} alt="diagram" />

Middleware is the concept that refers to a layer of code that lies between your handler and the caller using the `IMediator`. It provides you with a 
`before` and `after` hook to do things like logging, caching, error handling, etc.  You can mutate the results or short circuit it if necessary.

Our middleware follows the same general principles from ASP.NET Core.  Shiny Mediator supports middleware for both requests and events, however, they 
are two separate pipelines.

As with ASP.NET Core, when you're implementing middleware, you have a `next` parameter that you must call to continue the pipeline.

:::note
The ability to skip middleware in any call is easy.  Just add the following header to any Send/Request/Publish call

```csharp
IMediator medidator; //injected
mediator.Send(new MyRequest(), CancellationToken.None, Headers.BypassMiddleware);
```
:::

## Configuration

Most of our extensions and middleware are configured through the Microsoft.Extensions.Configuration abstractions.  For MAUI and Blazor configuration, we recommend
using the `Microsoft.Extensions.Configuration.Json` package to load your configuration from an embedded resource. 

Here is an example of how you can load a configuration file from an embedded resource:

```csharp
builder.Configuration.AddJsonStream(Assembly.GetExecutingAssembly().GetManifestResourceStream("Sample.appsettings.json")!);
``

Below is an example of essentially every configuration option we have available.  This is a JSON representation of the configuration that you would load into your application.

```json
{
    "Mediator": {
        "Http": {
            "My.Namespace.Contract": "https://otherlocalhost",
            "My.Namespace.*" : "https://localhost"
        },
        "PerformanceLogging": {
            "*": {
                "ErrorThresholdMilliseconds": 5000
            }
        },
        "Offline": {
            "Sample.Handlers.OfflineRequestHandler": {
                "AvailableAcrossSessions": true
            }
        },
        "ReplayStream": {
            "*": {
                "AvailableAcrossSessions": true
            }
        },
        "TimerRefresh": {
            "My.Contracts.MainRequest": {
                "IntervalSeconds": 30
            }
        },
        "Resilience": {
            "My.Contracts.LongRequest": {
                "RetryCount": 3,
                "RetryDelay": 2000,
                "CircuitBreakerCount": 5,
                "CircuitBreakerDelay": 5000
            }
        },
        "Cache": {
            "My.Contracts.LongRequest": {
                "Priority": "High",
                "AbsoluteExpirationSeconds": 300,
                "SlidingExpirationSeconds": 60
            }
        },
        "UserErrorNotifications": {
            "My.Contracts.*": {
                "*": {
                    "Title": "ERROR",
                    "Message" : "Failed to do something"
                }
            }
        }
    }
}
```

Above is an example of all configurations we currently supported.  The configuration allows you to configure a specific contract/handler, namespace, or the entire mediator 
library to configure the middleware around it.

Here is the order we follow for setting up and grabbing a config for a call:

1. Contract Full Type Name (namespace + type)
2. Handler Full Type Name (namespace + type)
3. Contract Namespace (defined with namespace.*)
4. Handler Namespace (defined with namespace.*)
5. Everything

If no configuration is found, the middleware & extensions will move on to any attributes they may support.  If nothing is found there, the feature is considered
to be disabled for that contract.

:::danger
Configuring * on any middleware outside HTTP & Performance Logging can be dangerous.  Wildcards apply to all contracts in the scope you give it.
:::

## Registering Your Own Middleware

To register your own middleware, you simply need to implement the correct interface for the contract type you want to target.  Below is an example of a command middleware

:::danger
Your middleware should always call next unless it is breaking out of the pipeline early
:::

### Specific Types

```csharp
// 1. The Easiest way with our attributes
[MediatorSingleton] //or [MediatorTransient]
public class MyCommandMiddleware<TRequest, TResult> : ICommandMiddleware<TRequest, TResult>

// 2. The more manual way
services.AddSingletonAsImplementedInterfaces<MyCommandMiddleware<TRequest, TResult>>(); 

// 3. The most manual way
services.AddSingleton<ICommandMiddleware<TRequest, TResult>, MyCommandMiddleware<TRequest, TResult>>(); 
```

:::note
The registration methods above work for all middleware types - just change the interface and class names accordingly.
:::

### Generic Types

```csharp
// 1. The Easiest way with our attributes
[MediatorSingleton] //or [MediatorTransient]
public class MyCommandMiddleware<TRequest, TResult> : ICommandMiddleware<TRequest, TResult>

// 2. The open generic way
services.AddSingleton(typeof(ICommandMiddleware<,>), typeof(MyCommandMiddleware<,>));
services.AddSingleton(typeof(IRequestMiddleware<,>), typeof(MyRequestMiddleware<,>));
services.AddSingleton(typeof(IStreamRequestMiddleware<,>), typeof(MyStreamRequestMiddleware<,>));
services.AddSingleton(typeof(IEventMiddleware<>), typeof(MyEventMiddleware<>));
```

### My Middleware Uses a Method Attribute

This is normally a problem as retrieving method level attributes requires deep reflection which does NOT comply with AOT. 
We also like to use method level attributes, as such, we made a source generator that knows how to look at attributes
on methods for handlers.  You're new attribute just needs to implement `MediatorMiddlewareAttribute`.

```csharp
public class MyCustomMiddlewareAttribute : Attribute, MediatorMiddlewareAttribute
{
    public string SomeProperty { get; set; }
}

public class MyMiddleware<TRequest, TResult> : IRequestMiddleware<TRequest, TResult> where TRequest : IRequest<TResult>
{
    public async Task<TResult> Handle(
        IMediatorContext context,
        RequestHandlerDelegate<TResult> next,
        CancellationToken cancellationToken
    )
    {
        var attribute = context.GetHandlerAttribute<CacheAttribute>();
        if (attribute != null)
        {
            
        }

        return await next(request, context, ct);
    }
}
```

### Using Contract Keys in your Middleware

```csharp
public class MyCustomMiddleware<TRequest, TResult>(
    IContractKeyProvider contractKeyProvider
) : IRequestMiddleware<TRequest, TResult> where TRequest : IRequest<TResult>
{
    public async Task<TResult> Handle(
        IMediatorContext context,
        RequestHandlerDelegate<TResult> next,
        CancellationToken cancellationToken
    )
    {
        var contactKey = contractKeyProvider.GetContractKey(context.Message!);

        
        return await next(request, context, ct);
    }
}
```